---
title: 异步处理顺序问题
date: 2023-08-18 13:03:04
tags:
---
``
function switchMap(fn) {
    let id = 0;
    let last= 0;
    let cache;

    return new Proxy(fn, {
        async apply (_, this, args) {
            const temp = id;
            id++;
        
            const result = await Reflect.apply(_, this, args);
           
            if (temp < last) {
                return cache;
            }

            cache = result;
            last = temp;
            return result;
        }
    })
}


function wait(param) {
    return new Promise((resolve) => {
        if ('number' === typeof param) {
            setTimeout(resolve, param);
        } else if ('function' === param) {
            const timer = setInterval(() => {
                if (param()) {
                    clearInterval(timer);
                    resolve();
                }
            }, 100);
        } else {
            resolve();
        }
    });
}


function mergeMap(fn) {
    let id = 0;
    let ids = new Set();

    return new Proxy(fn, {
        async apply (_, this, args) {
           const task = Reflect.apply(_, this, args);
           const temp = id;
           id++;
           ids.add(temp);
           await wait(() => !ids.has(temp - 1));
           ids.delete(temp);
           return await task;
        }
    });
}

function concatMap(fn) {
    let id = 0;
    let ids = new Set();

    return new Proxy(fn, {
        async apply (_, this, args) {
           const temp = id;
           id++;
           ids.add(temp);
           await wait(() => !ids.has(temp - 1));
           const task = Reflect.apply(_, this, args);
           ids.delete(temp);
           return await task;
        }
    });
}
``